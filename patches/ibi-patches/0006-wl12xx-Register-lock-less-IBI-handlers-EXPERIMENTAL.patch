From 74945e5296582c4ab417351627c566321d7986e8 Mon Sep 17 00:00:00 2001
From: Ido Yariv <ido@wizery.com>
Date: Mon, 2 Jan 2012 21:50:02 +0200
Subject: [PATCH 06/14] wl12xx: Register lock-less IBI handlers *EXPERIMENTAL*

wl->mutex is normally acquired before claiming the mmc host. In the case of IBI, the handler is called with
the host already claimed. This means that acquiring the mutex in the handler will result in an incorrect
locking order, which could lead to a deadlock.

Fix this by registering the handler as a lock-less one, and claim the host after acquiring the mutex.

Signed-off-by: Ido Yariv <ido@wizery.com>
Signed-off-by: Eliad Peller <eliad@wizery.com>
---
 drivers/net/wireless/ti/wlcore/main.c   |    3 ++-
 drivers/net/wireless/ti/wlcore/sdio.c   |   26 +++++++++++++++++++++++---
 drivers/net/wireless/ti/wlcore/wlcore.h |    1 +
 3 files changed, 26 insertions(+), 4 deletions(-)

diff --git a/drivers/net/wireless/ti/wlcore/main.c b/drivers/net/wireless/ti/wlcore/main.c
index ffad5d3..c746dae 100644
--- a/drivers/net/wireless/ti/wlcore/main.c
+++ b/drivers/net/wireless/ti/wlcore/main.c
@@ -533,7 +533,7 @@ static void wl1271_netstack_work(struct work_struct *work)
 
 #define WL1271_IRQ_MAX_LOOPS 256
 
-static int wlcore_irq_locked(struct wl1271 *wl)
+int wlcore_irq_locked(struct wl1271 *wl)
 {
 	int ret = 0;
 	u32 intr;
@@ -661,6 +661,7 @@ static int wlcore_irq_locked(struct wl1271 *wl)
 out:
 	return ret;
 }
+EXPORT_SYMBOL(wlcore_irq_locked);
 
 irqreturn_t wlcore_irq(int irq, void *cookie)
 {
diff --git a/drivers/net/wireless/ti/wlcore/sdio.c b/drivers/net/wireless/ti/wlcore/sdio.c
index ef3deb4..35960cd 100644
--- a/drivers/net/wireless/ti/wlcore/sdio.c
+++ b/drivers/net/wireless/ti/wlcore/sdio.c
@@ -219,6 +219,10 @@ static void wl12xx_sdio_interrupt(struct sdio_func *func)
 
 	dev_dbg(&func->dev, "SDIO IRQ");
 
+	/* TX might be handled here, avoid redundant work */
+	set_bit(WL1271_FLAG_TX_PENDING, &wl->flags);
+	cancel_work_sync(&wl->tx_work);
+
 	if (WARN_ON(!glue->handler || !glue->thread_fn))
 		return;
 
@@ -227,10 +231,26 @@ static void wl12xx_sdio_interrupt(struct sdio_func *func)
 
 	ret = glue->handler(0, glue->irq_cookie);
 	if (ret == IRQ_WAKE_THREAD) {
+
+		mutex_lock(&wl->mutex);
+		if (sdio_claim_host_irq(func)) {
+			/*
+			 * Theoretically we need to reschedule TX work.
+			 * Practically, if the irq is freed, there's little
+			 * point in doing so.
+			 */
+			mutex_unlock(&wl->mutex);
+			return;
+		}
+		wlcore_irq_locked(wl);
 		sdio_release_host(func);
-		glue->thread_fn(0, glue->irq_cookie);
-		sdio_claim_host(func);
+		mutex_unlock(&wl->mutex);
 	}
+	/*
+	 * Again, we shouldn't reschedule TX work in an else clause because the
+	 * system is suspended and the interrupt handler will be called when it
+	 * is resumed
+	 */
 }
 
 int wl12xx_sdio_request_irq(struct device *child,
@@ -255,7 +275,7 @@ int wl12xx_sdio_request_irq(struct device *child,
 	glue->handler = handler;
 	glue->thread_fn = thread_fn;
 	glue->irq_cookie = cookie;
-	ret = sdio_claim_irq(func, wl12xx_sdio_interrupt);
+	ret = sdio_claim_irq_lockless(func, wl12xx_sdio_interrupt);
 	sdio_release_host(func);
 	printk("claiming sdio irq (func=%d). ret=%d\n", func->num, ret);
 	return ret;
diff --git a/drivers/net/wireless/ti/wlcore/wlcore.h b/drivers/net/wireless/ti/wlcore/wlcore.h
index bf5bf6d..2a6f26b 100644
--- a/drivers/net/wireless/ti/wlcore/wlcore.h
+++ b/drivers/net/wireless/ti/wlcore/wlcore.h
@@ -482,6 +482,7 @@ void wlcore_update_inconn_sta(struct wl1271 *wl, struct wl12xx_vif *wlvif,
 			      struct wl1271_station *wl_sta, bool in_conn);
 irqreturn_t wl12xx_hardirq(int irq, void *cookie);
 irqreturn_t wlcore_irq(int irq, void *cookie);
+int wlcore_irq_locked(struct wl1271 *wl);
 
 static inline void
 wlcore_set_ht_cap(struct wl1271 *wl, enum ieee80211_band band,
-- 
1.7.9.5

