From 002dbd45aa8e7c6b95e254101e4e077ba3bc4135 Mon Sep 17 00:00:00 2001
From: Eliad Peller <eliad@wizery.com>
Date: Thu, 3 Nov 2011 14:55:18 +0200
Subject: [PATCH 03/14] wl18xx: enable/disable sdio irq on resume

call the new sdio_disable_irq when getting an irq
while the host is suspended and enable-only
it (sdio_enable_irq) on resume.

Signed-off-by: Eliad Peller <eliad@wizery.com>
---
 drivers/net/wireless/ti/wlcore/sdio.c |   15 +++++++++++++++
 1 file changed, 15 insertions(+)

diff --git a/drivers/net/wireless/ti/wlcore/sdio.c b/drivers/net/wireless/ti/wlcore/sdio.c
index 3c63ac2..6678fd3 100644
--- a/drivers/net/wireless/ti/wlcore/sdio.c
+++ b/drivers/net/wireless/ti/wlcore/sdio.c
@@ -214,11 +214,17 @@ static int wl12xx_sdio_set_power(struct device *child, bool enable)
 static void wl12xx_sdio_interrupt(struct sdio_func *func)
 {
 	struct wl12xx_sdio_glue *glue = sdio_get_drvdata(func);
+	struct wl1271 *wl = platform_get_drvdata(glue->core);
 	irqreturn_t ret;
 
+	dev_dbg(&func->dev, "SDIO IRQ");
+
 	if (WARN_ON(!glue->handler || !glue->thread_fn))
 		return;
 
+	if (test_bit(WL1271_FLAG_SUSPENDED, &wl->flags))
+		sdio_disable_irq(func);
+
 	ret = glue->handler(0, glue->irq_cookie);
 	if (ret == IRQ_WAKE_THREAD) {
 		sdio_release_host(func);
@@ -234,8 +240,17 @@ int wl12xx_sdio_request_irq(struct device *child,
 {
 	struct wl12xx_sdio_glue *glue = dev_get_drvdata(child->parent);
 	struct sdio_func *func = dev_to_sdio_func(glue->dev);
+	struct wl1271 *wl = platform_get_drvdata(glue->core);
 	int ret;
 
+	/* irq is already claimed. we just need to enable it */
+	if (wl->inband_claimed) {
+		sdio_claim_host(func);
+		sdio_enable_irq(func);
+		sdio_release_host(func);
+		return 0;
+	}
+
 	sdio_claim_host(func);
 	glue->handler = handler;
 	glue->thread_fn = thread_fn;
-- 
1.7.9.5

